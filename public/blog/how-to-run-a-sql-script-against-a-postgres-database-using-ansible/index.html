<!DOCTYPE html>
<html lang="en-US" class="scroll-smooth dark">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>

<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>How to run a SQL Script Against a Postgres Database Using Ansible</title>
<meta
  name="description"
  content="The source code for this post can be found on GitHub.
Managing a live database, and in particular dealing with database migrations without allowing for any downtime in your application, is typically the most challenging part of any automated deployment strategy. Services can be spun up and down with impunity because their state at the beginning and at the end are exactly the same, but databases store data&ndash;their state is always changing."
/>
<link rel="canonical" href="http://localhost:1313/blog/how-to-run-a-sql-script-against-a-postgres-database-using-ansible/" />
<link rel="robots" href="/robots.txt" />

<link rel="icon" type="image/x-icon" href="/icons/favicon.ico" />



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>

<link rel="stylesheet" href="http://localhost:1313/css/app.css" /></head>

  <body class="max-w-screen-md mx-auto px-2.5">
    <div class="header">
      <header class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 py-12">
   


<div class="flex-none w-20 h-20 rounded-full overflow-hidden">
  <a href="http://localhost:1313/">
    <img
      srcset="/img/profile-picture_hu4241499301404582006.jpg 80w"
      src="/img/profile-picture.jpg"
      width="386"
      height="345"
      alt="Nick Fisher&#39;s tech blog"
    />
  </a>
</div>

  
  <div class="flex flex-col gap-5">
    <a href="http://localhost:1313/">
  <h1 id="site-title">Nick Fisher&#39;s tech blog</h1>
</a>
 
    <nav>
  <ul>
     
    
    <li>
      <a href="/" class="">
        home
      </a>
    </li>
    
    <li>
      <a href="/blog" class="">
        blog
      </a>
    </li>
    
    <li>
      <a href="/about" class="">
        about
      </a>
    </li>
    
    <li>
      <a href="/tags" class="">
        Tags
      </a>
    </li>
    
  </ul>
</nav>

  </div>
</header>

      <button class="toggle-theme" aria-label="Toggle Theme" title="Toggle Theme" onclick="toggleTheme()">
  <span class="theme-icon light"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg> </span>
  <span class="theme-icon dark"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg> </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme === 'light') {
      setTheme('light');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script>
    </div>
  
    <main id="content">

<article class="flex flex-col gap-10">
  <header class="flex flex-col gap-2">
    <h2 class="title-large">How to run a SQL Script Against a Postgres Database Using Ansible</h2>

    <div class="meta">
      
      <time datetime="2019-02-09 15:44:26 &#43;0000 UTC" title='Sat, Feb 9, 2019, 3:44 PM UTC'>
        09/02/2019 - Estimated reading time: 3 minutes
      </time>

       
      
    </div>
  </header>

  

  <section><p>The source code for this post can be found <a href="https://github.com/nfisher23/run-sql-ansible-postgres">on GitHub</a>.</p>
<p>Managing a live database, and in particular dealing with database migrations without allowing for any downtime in your application, is typically the most challenging part of any automated deployment strategy. Services can be spun up and down with impunity because their state at the beginning and at the end are exactly the same, but databases store data&ndash;their state is always changing.</p>
<p>From where I sit, there are two good options for dealing with database migrations: at an application level (e.g. a startup script when you connect with a service) or using a tool like Ansible. Either one of them allow you to write automation for the migrations, which is (in my opinion) non-negotiable for maintaining any non-trivial software project. While I lean towards the application owning the migrations, Ansible or another idempotent management tool is a somewhat close second, and may be better for your use case.</p>
<p>There are a few different ways to run a SQL script against Postgres using Ansible. The first is to take a sql file and dump it on the server you're managing, then run the sql script using a psql command. First we'll install Postgres for a Debian distribution with apt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># tasks file for run-sql-postgres</span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: install postgres
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">apt</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">update_cache</span>: <span style="color:#ff79c6">yes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">name</span>: [<span style="color:#ff79c6">&amp;#39;postgresql&amp;#39;,</span> <span style="color:#ff79c6">&amp;#39;postgresql-contrib&amp;#39;]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">state</span>: present
</span></span></code></pre></div><p>Next I'll create a testing database to run the scripts against with the built in postgresql_db ansible module:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: ensure psycopg2
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">apt</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">name</span>: python-psycopg2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: ensure testing database created
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">postgresql_db</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">name</span>: testdb <span style="color:#6272a4"># required. name of the database to add or remove</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">become_user</span>: postgres
</span></span></code></pre></div><p>In our ansible role directory, we'll create a <strong>files/migrate.sql</strong> file with the following contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> <span style="color:#ff79c6">IF</span> <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">EXISTS</span> products (
</span></span><span style="display:flex;"><span>    product_id <span style="color:#8be9fd;font-style:italic">serial</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    name <span style="color:#8be9fd;font-style:italic">varchar</span>(<span style="color:#bd93f9">100</span>),
</span></span><span style="display:flex;"><span>    price <span style="color:#8be9fd;font-style:italic">numeric</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>With the file in place, we can return to our <strong>tasks/main.yml</strong> file and add a first example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#6272a4"># first method</span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: dump a database file
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">copy</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">dest</span>: /etc/migrate.sql
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">src</span>: migrate.sql
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">register</span>: sql_file_path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: run custom sql script
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">command</span>: <span style="color:#ff79c6">&amp;#34;psql</span> testdb -f {{ sql_file_path.dest }}&amp;#34;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">become_user</span>: postgres
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">register</span>: sql_response_file
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: debug response
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">debug</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">var</span>: sql_response_file
</span></span></code></pre></div><p>This sends the file to <strong>/etc/migrate.sql</strong>, then uses the command module to run psql with the <strong>-f</strong> option for files. You can run it yourself and see the type of response that you're getting. With this method, it will <strong>always</strong> report the &quot;run custom sql script&quot; task as <strong>changed</strong>. You can optionally choose to modify that behavior with the changed_when option.</p>
<p>The second method will read the file into a variable, then use the variable to run psql with the <strong>-c</strong> option for command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#6272a4"># second method</span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: load sql into variable
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">set_fact</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">migrate_sql</span>: <span style="color:#ff79c6">&amp;#34;{{</span> lookup(&amp;#39;file&amp;#39;, &amp;#39;migrate.sql&amp;#39;) }}&amp;#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: debug variable
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">debug</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">var</span>: migrate_sql
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: run custom script from variable
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">command</span>: psql testdb -c &amp;#34;{{ migrate_sql }}&amp;#34;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">become_user</span>: postgres
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">register</span>: sql_response_variable
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">debug</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">var</span>: sql_response_variable
</span></span></code></pre></div><p>In both cases, the variables will report a virtually identical output.</p>
</section>

  
    
  

    
  


  <footer>
    
      <div class="pb-14 taxonomy-list tags-list">
      
        <a href="/tags/ansible/" alt="Ansible">
          Ansible
        </a>
      
        <a href="/tags/devops/" alt="DevOps">
          DevOps
        </a>
      
        <a href="/tags/postgresql/" alt="PostgreSQL">
          PostgreSQL
        </a>
      
      </div>
    
  </footer>
</article>


    </main><footer class="pt-5 pb-10 grid gap-3 sm:grid-cols-2">
    <div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">
  © 2018-2025 —
  <a href="http://localhost:1313/">Nick Fisher&#39;s tech blog</a> 
</div>

    <div class="order-1 sm:order-2">
  <ul class="flex sm:justify-end gap-5">
    
    
    <li>    
      <a href="https://www.linkedin.com/in/nick-fisher-software/" target="_blank" rel="noopener noreferrer">LinkedIn</a>
    </li>
    
    <li>    
      <a href="https://github.com/nfisher23" target="_blank" rel="noopener noreferrer">GitHub</a>
    </li>
    
    
  </ul>
</div>

</footer></body>
</html>
