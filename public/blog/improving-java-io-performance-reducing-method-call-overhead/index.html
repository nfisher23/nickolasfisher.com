<!DOCTYPE html>
<html lang="en-US" class="scroll-smooth dark">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>

<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Improving Java IO Performance: Reducing Method Call Overhead</title>
<meta
  name="description"
  content="You can view the sample code associated with this blog post on GitHub.
While you can achieve massive improvements in I/O operations via buffering, another key part of tuning java code in general, which is applicable to I/O bound operations, is method call overhead. Methods that are unnecessarily called repeatedly can bog down operations."
/>
<link rel="canonical" href="http://localhost:1313/blog/improving-java-io-performance-reducing-method-call-overhead/" />
<link rel="robots" href="/robots.txt" />

<link rel="icon" type="image/x-icon" href="/icons/favicon.ico" />



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>

<link rel="stylesheet" href="http://localhost:1313/css/app.css" /></head>

  <body class="max-w-screen-md mx-auto px-2.5">
    <div class="header">
      <header class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 py-12">
   


<div class="flex-none w-20 h-20 rounded-full overflow-hidden">
  <a href="http://localhost:1313/">
    <img
      srcset="/img/profile-picture_hu4241499301404582006.jpg 80w"
      src="/img/profile-picture.jpg"
      width="386"
      height="345"
      alt="Nick Fisher&#39;s tech blog"
    />
  </a>
</div>

  
  <div class="flex flex-col gap-5">
    <a href="http://localhost:1313/">
  <h1 id="site-title">Nick Fisher&#39;s tech blog</h1>
</a>
 
    <nav>
  <ul>
     
    
    <li>
      <a href="/" class="">
        home
      </a>
    </li>
    
    <li>
      <a href="/blog" class="">
        blog
      </a>
    </li>
    
    <li>
      <a href="/about" class="">
        about
      </a>
    </li>
    
    <li>
      <a href="/tags" class="">
        Tags
      </a>
    </li>
    
  </ul>
</nav>

  </div>
</header>

      <button class="toggle-theme" aria-label="Toggle Theme" title="Toggle Theme" onclick="toggleTheme()">
  <span class="theme-icon light"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg> </span>
  <span class="theme-icon dark"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg> </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme === 'light') {
      setTheme('light');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script>
    </div>
  
    <main id="content">

<article class="flex flex-col gap-10">
  <header class="flex flex-col gap-2">
    <h2 class="title-large">Improving Java IO Performance: Reducing Method Call Overhead</h2>

    <div class="meta">
      
      <time datetime="2018-11-17 18:06:13 &#43;0000 UTC" title='Sat, Nov 17, 2018, 6:06 PM UTC'>
        17/11/2018 - Estimated reading time: 2 minutes
      </time>

       
      
    </div>
  </header>

  

  <section><p>You can view the sample code associated with this blog post <a href="https://github.com/nfisher23/io-tuning">on GitHub.</a></p>
<p>While you can achieve massive improvements in I/O operations via <a href="https://nickolasfisher.com/blog/Improving-Java-IO-Performance-Buffering-Techniques">buffering</a>, another key part of tuning java code in general, which is applicable to I/O bound operations, is method call overhead. Methods that are unnecessarily called repeatedly can bog down operations.</p>
<p>To prove my point, we'll set up benchmarking via JMH like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">runBenchmark</span>(Class clazz) <span style="color:#8be9fd;font-style:italic">throws</span> Exception {
</span></span><span style="display:flex;"><span>        Options options <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> OptionsBuilder()
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">include</span>(clazz.<span style="color:#50fa7b">getName</span>() <span style="color:#ff79c6">&amp;</span>#43; <span style="color:#ff79c6">&amp;</span>#34;.<span style="color:#ff79c6">*&amp;</span>#34;)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">mode</span>(Mode.<span style="color:#50fa7b">AverageTime</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">warmupTime</span>(TimeValue.<span style="color:#50fa7b">seconds</span>(1))
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">warmupIterations</span>(2)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">measurementIterations</span>(2)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">timeUnit</span>(TimeUnit.<span style="color:#50fa7b">MILLISECONDS</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">measurementTime</span>(TimeValue.<span style="color:#50fa7b">seconds</span>(1))
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// OS bottleneck, so we use should one</span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// thread at a time for accurate results</span>
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">threads</span>(1)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">forks</span>(1)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">shouldFailOnError</span>(<span style="color:#ff79c6">true</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">shouldDoGC</span>(<span style="color:#ff79c6">true</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#50fa7b">build</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">new</span> Runner(options).<span style="color:#50fa7b">run</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We'll have a benchmark that uses DataInputStream.readLine(), which calls read() under the hood on each character. Even though we are buffering the data, we are still calling read() on each byte that has already been loaded into memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    @Benchmark
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">readEachCharacterUnderTheHood</span>() <span style="color:#8be9fd;font-style:italic">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">try</span> (FileInputStream fileInputStream <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> FileInputStream(Utils.<span style="color:#50fa7b">smallCsvFilePath</span>);
</span></span><span style="display:flex;"><span>             BufferedInputStream bufferedInputStream <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BufferedInputStream(fileInputStream);
</span></span><span style="display:flex;"><span>             DataInputStream dataInputStream <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> DataInputStream(bufferedInputStream)) {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd">int</span> count <span style="color:#ff79c6">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">while</span> (dataInputStream.<span style="color:#50fa7b">readLine</span>() <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span>) {
</span></span><span style="display:flex;"><span>                count<span style="color:#ff79c6">&amp;</span>#43;<span style="color:#ff79c6">&amp;</span>#43;;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            assertEquals(Utils.<span style="color:#50fa7b">numberOfNewLines_inSmallCsv</span>, count);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The performance of this method on my machine is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Benchmark                                              Mode  Cnt  Score   Error  Units
</span></span><span style="display:flex;"><span>MethodCallOverheadTests.readEachCharacterUnderTheHood  avgt    <span style="color:#bd93f9">2</span>  1.560          ms/op
</span></span></code></pre></div><p>Conversely, BufferedReader is implemented to buffer the buffer, so that the underlying stream does not get hit with repeated method calls. From the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">Oracle documentation on the BufferedReader class</a>:</p>
<p>&gt; In general, each read request made of a Reader causes a corresponding
&gt; read request to be made of the underlying character or byte stream. It is
&gt; therefore advisable to wrap a BufferedReader around any Reader whose read()
&gt; operations may be costly, such as FileReaders and InputStreamReaders.</p>
<p>And:</p>
<p>&gt; Programs that use DataInputStreams for textual input can be localized by
&gt; replacing each DataInputStream with an appropriate BufferedReader.</p>
<p>So, a benchmark that achieves the same result would look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    @Benchmark
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">faster_usingBufferedReader</span>() <span style="color:#8be9fd;font-style:italic">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">try</span> (FileReader fileReader <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> FileReader(Utils.<span style="color:#50fa7b">smallCsvFilePath</span>);
</span></span><span style="display:flex;"><span>             BufferedReader bufferedReader <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BufferedReader(fileReader)) {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd">int</span> count <span style="color:#ff79c6">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">while</span> (bufferedReader.<span style="color:#50fa7b">readLine</span>() <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span>) {
</span></span><span style="display:flex;"><span>                count<span style="color:#ff79c6">&amp;</span>#43;<span style="color:#ff79c6">&amp;</span>#43;;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            assertEquals(Utils.<span style="color:#50fa7b">numberOfNewLines_inSmallCsv</span>, count);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>When run back to back, the benchmarks on my machine look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Benchmark                                              Mode  Cnt  Score   Error  Units
</span></span><span style="display:flex;"><span>MethodCallOverheadTests.faster_usingBufferedReader     avgt    <span style="color:#bd93f9">2</span>  0.700          ms/op
</span></span><span style="display:flex;"><span>MethodCallOverheadTests.readEachCharacterUnderTheHood  avgt    <span style="color:#bd93f9">2</span>  1.560          ms/op
</span></span></code></pre></div><p>Or, the BufferedReader is indeed ~2 times as fast.</p>
</section>

  
    
  

    
  


  <footer>
    
      <div class="pb-14 taxonomy-list tags-list">
      
        <a href="/tags/java/" alt="Java">
          Java
        </a>
      
        <a href="/tags/i/o/" alt="I/O">
          I/O
        </a>
      
        <a href="/tags/performance-testing/" alt="Performance Testing">
          Performance Testing
        </a>
      
        <a href="/tags/jmh/" alt="Jmh">
          Jmh
        </a>
      
      </div>
    
  </footer>
</article>


    </main><footer class="pt-5 pb-10 grid gap-3 sm:grid-cols-2">
    <div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">
  © 2018-2025 —
  <a href="http://localhost:1313/">Nick Fisher&#39;s tech blog</a> 
</div>

    <div class="order-1 sm:order-2">
  <ul class="flex sm:justify-end gap-5">
    
    
    <li>    
      <a href="https://www.linkedin.com/in/nick-fisher-software/" target="_blank" rel="noopener noreferrer">LinkedIn</a>
    </li>
    
    <li>    
      <a href="https://github.com/nfisher23" target="_blank" rel="noopener noreferrer">GitHub</a>
    </li>
    
    
  </ul>
</div>

</footer></body>
</html>
