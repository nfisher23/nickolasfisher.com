<!doctype html><html lang=en-US class="scroll-smooth dark"><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Optimistic Locking in Redis with Reactive Lettuce</title>
<meta name=description content="The source code for what follows can be found on Github.
Optimistic Locking in Redis is one of the only reasons to want to use transactions, in my opinion. You can ensure a grouping of atomic operations only occur if a watched key does not change out from underneath you. On the CLI, this might start with:"><link rel=canonical href=https://www.nickolasfisher.com/blog/optimistic-locking-in-redis-with-reactive-lettuce/><link rel=robots href=/robots.txt><link rel=icon type=image/x-icon href=/img/nficon.png><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script><link rel=stylesheet href="https://www.nickolasfisher.com/css/app.min.dee9c4afb37cb95c5d39c976614ef6f95398bcba4b6e73066c44de2a3a6543ed.css"></head><body class="max-w-screen-md mx-auto px-2.5"><div class=header><header class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 py-12"><div class="flex-none w-20 h-20 rounded-full overflow-hidden"><a href=https://www.nickolasfisher.com/><img srcset="/img/profile-picture_hu4241499301404582006.jpg 80w" src=/img/profile-picture.jpg width=386 height=345 alt="Nick Fisher's tech blog"></a></div><div class="flex flex-col gap-5"><a href=https://www.nickolasfisher.com/><h1 id=site-title>Nick Fisher's tech blog</h1></a><nav><ul><li><a href=/>home</a></li><li><a href=/blog>blog</a></li><li><a href=/about>about</a></li><li><a href=/tags>Tags</a></li></ul></nav></div></header><button class=toggle-theme aria-label="Toggle Theme" title="Toggle Theme" onclick=toggleTheme()>
<span class="theme-icon light"><svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75.0 11-7.5.0 3.75 3.75.0 017.5.0z"/></svg> </span><span class="theme-icon dark"><svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718.0 0118 15.75c-5.385.0-9.75-4.365-9.75-9.75.0-1.33.266-2.597.748-3.752A9.753 9.753.0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753.0 009.002-5.998z"/></svg> </span></button>
<script>document.addEventListener("DOMContentLoaded",function(){const e=localStorage.getItem("theme");setTheme(!e||e==="light"?"light":e)});function setTheme(e){const t=document.querySelector("html");localStorage.setItem("theme",e),e==="light"?(t.classList.contains("dark")&&document.querySelector("html").classList.remove("dark"),document.querySelector(".theme-icon.light").style.display="none",document.querySelector(".theme-icon.dark").style.display="block"):(t.classList.contains("dark")||document.querySelector("html").classList.add("dark"),document.querySelector(".theme-icon.dark").style.display="none",document.querySelector(".theme-icon.light").style.display="block")}function toggleTheme(){const e=localStorage.getItem("theme");setTheme(e==="light"?"dark":"light")}</script></div><main id=content><article class="flex flex-col gap-10"><header class="flex flex-col gap-2"><h2 class=title-large>Optimistic Locking in Redis with Reactive Lettuce</h2><div class=meta><time datetime="2021-04-24 21:32:36 +0000 UTC" title='Sat, Apr 24, 2021, 9:32 PM UTC'>24/04/2021 - Estimated reading time: 3 minutes</time></div></header><section><p>The source code for what follows <a href=https://github.com/nfisher23/reactive-programming-webflux>can be found on Github</a>.</p><p>Optimistic Locking in Redis is one of the only reasons to want to use transactions, in my opinion. You can ensure a grouping of atomic operations only occur if a watched key does not change out from underneath you. On the CLI, this might start with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; SET key1 value1
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; WATCH key1
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MULTI
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>WATCH is saying &ldquo;redis, watch key1 for me, and if it changes at all then rollback the transaction I am about to start.&rdquo; Then we actually start the transaction with MULTI.</p><p>Now on this same thread, let&rsquo;s say we issue two commands before committing [before the EXEC, command, that is]:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; SET key2 value2
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SET key1 newvalue
</span></span><span style=display:flex><span>QUEUED
</span></span></code></pre></div><p>Obviously, because we&rsquo;re in a transaction, we have not actually &ldquo;committed&rdquo; either of these just yet. If we now start up another terminal and run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># different shell than the one with the open transaction</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SET key1 changedbysomeoneelse
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>And then we try to commit the transaction we started above, we can see that it fails and neither operation was successful [which is the atomicity that we&rsquo;re looking for]:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># shell that has the open transaction</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; EXEC
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>nil<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GET key2
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>nil<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GET key1
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;changedbysomeoneelse&#34;</span>
</span></span></code></pre></div><p>So that&rsquo;s what it looks like on the CLI, what does optimistic locking look like in lettuce?</p><h3 id=optimistic-locking-with-reactive-lettuce>Optimistic Locking with Reactive Lettuce</h3><p>As I droned on about my last article on <a href=https://nickolasfisher.com/blog/Redis-Transactions-Reactive-Lettuce-Buyer-Beware>transactions in redis using lettuce</a>, you have to be very careful using any of what follows, but if you&rsquo;re sure you want to try it here it goes.</p><p>To really appreciate what follows, you will want to read that last post, and probably make sure you have something like <a href=https://nickolasfisher.com/blog/How-to-use-a-Redis-Test-Container-with-LettuceSpring-Boot-Webflux>a redis test container set up for lettuce</a>. We will want to start by creating two connections, then we can start a transaction using one of them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>optLocking</span>() {
</span></span><span style=display:flex><span>        RedisReactiveCommands<span style=color:#ff79c6>&lt;</span>String, String<span style=color:#ff79c6>&gt;</span> firstConnection <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>                redisClient.<span style=color:#50fa7b>connect</span>().<span style=color:#50fa7b>reactive</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        RedisReactiveCommands<span style=color:#ff79c6>&lt;</span>String, String<span style=color:#ff79c6>&gt;</span> secondConnection <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>                redisClient.<span style=color:#50fa7b>connect</span>().<span style=color:#50fa7b>reactive</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        firstConnection.<span style=color:#50fa7b>watch</span>(<span style=color:#f1fa8c>&#34;key-1&#34;</span>).<span style=color:#50fa7b>subscribe</span>();
</span></span><span style=display:flex><span>        firstConnection.<span style=color:#50fa7b>multi</span>().<span style=color:#50fa7b>subscribe</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Similar to the CLI example above, we are first watching &ldquo;key-1&rdquo; for any changes, then starting a transaction. If &ldquo;key-1&rdquo; is modified by a different process while we execute anything in the following code using that connection, then it will roll back. Here&rsquo;s some code demonstrating that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        firstConnection.<span style=color:#50fa7b>incr</span>(<span style=color:#f1fa8c>&#34;key-1&#34;</span>).<span style=color:#50fa7b>subscribe</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        secondConnection.<span style=color:#50fa7b>set</span>(<span style=color:#f1fa8c>&#34;key-1&#34;</span>, <span style=color:#f1fa8c>&#34;10&#34;</span>).<span style=color:#50fa7b>subscribe</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        StepVerifier.<span style=color:#50fa7b>create</span>(firstConnection.<span style=color:#50fa7b>exec</span>())
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// transaction not committed</span>
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>expectNextMatches</span>(tr <span style=color:#ff79c6>-&gt;</span> tr.<span style=color:#50fa7b>wasDiscarded</span>())
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>verifyComplete</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        StepVerifier.<span style=color:#50fa7b>create</span>(secondConnection.<span style=color:#50fa7b>get</span>(<span style=color:#f1fa8c>&#34;key-1&#34;</span>))
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>expectNextMatches</span>(val <span style=color:#ff79c6>-&gt;</span> <span style=color:#f1fa8c>&#34;10&#34;</span>.<span style=color:#50fa7b>equals</span>(val))
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>verifyComplete</span>();
</span></span></code></pre></div><p>We increment &ldquo;key-1&rdquo; in the existing transaction, then use a different connection [which is obviously not in the same transaction] to change that key. When we then try to commit the transaction, redis aborts it on our behalf because that key has already been changed by a different thread.</p><p>I would still recommend you find a different way to solve your problem due to the caveats mentioned in that last post, but if you&rsquo;re intent on doing it, this approach could technically work.</p></section><footer><div class="pb-14 taxonomy-list tags-list"><a href=/tags/java/ alt=Java>Java
</a><a href=/tags/reactive/ alt=Reactive>Reactive
</a><a href=/tags/webflux/ alt=Webflux>Webflux
</a><a href=/tags/lettuce/ alt=Lettuce>Lettuce
</a><a href=/tags/redis/ alt=Redis>Redis</a></div></footer></article></main><footer class="pt-5 pb-10 grid gap-3 sm:grid-cols-2"><div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">© 2018-2025 —
<a href=https://www.nickolasfisher.com/>Nick Fisher's tech blog</a></div><div class="order-1 sm:order-2"><ul class="flex sm:justify-end gap-5"><li><a href=https://www.linkedin.com/in/nick-fisher-software/ target=_blank rel="noopener noreferrer">LinkedIn</a></li><li><a href=https://github.com/nfisher23 target=_blank rel="noopener noreferrer">GitHub</a></li></ul></div></footer></body></html>