<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AnsibleDevOpspostgreSQL on Nick Fisher&#39;s tech blog</title>
    <link>http://localhost:1313/tags/ansibledevopspostgresql/</link>
    <description>Recent content in AnsibleDevOpspostgreSQL on Nick Fisher&#39;s tech blog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>2018-{year}</copyright>
    <lastBuildDate>Sat, 09 Feb 2019 15:44:26 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/ansibledevopspostgresql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to run a SQL Script Against a Postgres Database Using Ansible</title>
      <link>http://localhost:1313/blog/how-to-run-a-sql-script-against-a-postgres-database-using-ansible/</link>
      <pubDate>Sat, 09 Feb 2019 15:44:26 +0000</pubDate>
      <guid>http://localhost:1313/blog/how-to-run-a-sql-script-against-a-postgres-database-using-ansible/</guid>
      <description>&lt;p&gt;The source code for this post can be found &lt;a href=&#34;https://github.com/nfisher23/run-sql-ansible-postgres&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Managing a live database, and in particular dealing with database migrations without allowing for any downtime in your application, is typically the most challenging part of any automated deployment strategy. Services can be spun up and down with impunity because their state at the beginning and at the end are exactly the same, but databases store data&amp;ndash;their state is always changing.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
