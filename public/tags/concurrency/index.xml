<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrency on Nick Fisher's tech blog</title><link>https://www.nickolasfisher.com/tags/concurrency/</link><description>Recent content in Concurrency on Nick Fisher's tech blog</description><generator>Hugo</generator><language>en-US</language><copyright>2018-{year}</copyright><lastBuildDate>Sat, 20 Mar 2021 19:14:57 +0000</lastBuildDate><atom:link href="https://www.nickolasfisher.com/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>How to Zip Reactor Mono Objects that Return Void</title><link>https://www.nickolasfisher.com/blog/how-to-zip-reactor-mono-objects-that-return-void/</link><pubDate>Sat, 20 Mar 2021 19:14:57 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-zip-reactor-mono-objects-that-return-void/</guid><description>&lt;p>Leveraging &lt;a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.lang.Iterable-java.util.function.Function-">Mono.zip&lt;/a> appropriately will [with the right configuration] lead to a high amount of performance and concurrency. There is one caveat to its usage though:&lt;/p></description></item><item><title>The Difference Between a Reactive Non-Blocking Model and Classic Asynchronous Code</title><link>https://www.nickolasfisher.com/blog/the-difference-between-a-reactive-nonblocking-model-and-classic-asynchronous-code/</link><pubDate>Sat, 06 Jul 2019 15:10:01 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-difference-between-a-reactive-nonblocking-model-and-classic-asynchronous-code/</guid><description>&lt;p>Reactive Programming is a very different way of thinking about doing work in a microservices environment. Anyone who has worked with a GUI, dating back to even to windows forms, is familiar with the event based model, but what does that mean when there is unpredictable latency involved? How does handing off to a thread to make a remote call differ from this new &amp;ldquo;reactive web&amp;rdquo;?&lt;/p></description></item><item><title>How to Configure Reactive Netty in Spring Boot, in Depth</title><link>https://www.nickolasfisher.com/blog/how-to-configure-reactive-netty-in-spring-boot-in-depth/</link><pubDate>Sat, 06 Jul 2019 14:30:43 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-configure-reactive-netty-in-spring-boot-in-depth/</guid><description>&lt;p>&lt;a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">Spring Boot&amp;rsquo;s WebFlux programming model&lt;/a> is pretty neat, but there isn&amp;rsquo;t a lot by way of explaining how to best leverage it to get the results you need. I wrote this blog post after tinkering with the configuration of Reactor Netty on Spring Boot.&lt;/p></description></item><item><title>How to Make Concurrent Service API Calls in Java Using Spring Boot</title><link>https://www.nickolasfisher.com/blog/how-to-make-concurrent-service-api-calls-in-java-using-spring-boot/</link><pubDate>Sat, 22 Jun 2019 20:48:30 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-make-concurrent-service-api-calls-in-java-using-spring-boot/</guid><description>&lt;p>The source code for this post can be found &lt;a href="https://github.com/nfisher23/java-concurrency-examples/tree/master">on GitHub&lt;/a>.&lt;/p>
&lt;p>When you&amp;rsquo;re in a microservice environment, it often makes sense to make some calls to multiple services at the same time. This allows for the time an operation needs to complete to be reduced from the &lt;em>sum&lt;/em> of all the time spent waiting to the &lt;em>maximum&lt;/em> time spent over the span of calls.&lt;/p></description></item></channel></rss>