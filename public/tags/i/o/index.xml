<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>I/O on Nick Fisher's tech blog</title><link>https://www.nickolasfisher.com/tags/i/o/</link><description>Recent content in I/O on Nick Fisher's tech blog</description><generator>Hugo</generator><language>en-US</language><copyright>2018-{year}</copyright><lastBuildDate>Sat, 17 Nov 2018 19:16:28 +0000</lastBuildDate><atom:link href="https://www.nickolasfisher.com/tags/i/o/index.xml" rel="self" type="application/rss+xml"/><item><title>Improving Java IO Performance: Caching Data, When Appropriate</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-caching-data-when-appropriate/</link><pubDate>Sat, 17 Nov 2018 19:16:28 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-caching-data-when-appropriate/</guid><description>&lt;p>The sample code for this post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>The biggest bottleneck with I/O resources on the filesystem is the operating system, which controls access to the filesystem. Reading from, and writing to, the operating system, is much more expensive than storing data in memory, and that is the subject of this post: caching.&lt;/p></description></item><item><title>Improving Java IO Performance: Appropriately Using Random Access Over Streams</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-appropriately-using-random-access-over-streams/</link><pubDate>Sat, 17 Nov 2018 18:37:39 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-appropriately-using-random-access-over-streams/</guid><description>&lt;p>The sample code for this blog post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>A flavor I/O performance optimization that applies specifically to the filesystem is the decision on when to use Random Access instead of something like a BufferedInputStream. Random access allows for accessing a file in a similar way as a large array of bytes stored on the filesystem. From the &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html">oracle documentation on the RandomAccessFile class&lt;/a>:&lt;/p></description></item><item><title>Improving Java IO Performance: Formatting Costs</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-formatting-costs/</link><pubDate>Sat, 17 Nov 2018 18:27:31 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-formatting-costs/</guid><description>&lt;p>The sample code associated with this blog post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>Another potential source of I/O bottlenecks, across any medium, could be the process you choose to format the data in in the first place. For example, XML used to be a standard way to send information across the wire or store in a backend system, but the size overhead of XML as compared to JSON is about double (not to mention it&amp;rsquo;s somehow harder to read when formatted compared to JSON).&lt;/p></description></item><item><title>Improving Java IO Performance: Reducing Method Call Overhead</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-reducing-method-call-overhead/</link><pubDate>Sat, 17 Nov 2018 18:06:13 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-reducing-method-call-overhead/</guid><description>&lt;p>You can view the sample code associated with this blog post &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub.&lt;/a>&lt;/p>
&lt;p>While you can achieve massive improvements in I/O operations via &lt;a href="https://nickolasfisher.com/blog/Improving-Java-IO-Performance-Buffering-Techniques">buffering&lt;/a>, another key part of tuning java code in general, which is applicable to I/O bound operations, is method call overhead. Methods that are unnecessarily called repeatedly can bog down operations.&lt;/p></description></item><item><title>Improving Java IO Performance: Buffering Techniques</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-buffering-techniques/</link><pubDate>Sat, 10 Nov 2018 12:45:54 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-buffering-techniques/</guid><description>&lt;p>ï»¿You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>Now that we know &lt;a href="https://nickolasfisher.com/blog/How-to-Benchmark-Java-Code-Using-JUnit-and-JMH">how to benchmark using junit and jmh&lt;/a>, let&amp;rsquo;s put it to the test and try to optimize some basic I/O operations. While filesystem tasks are much less common in the web-enabled world, understanding the basics can help us when we move on to streams across network connections.&lt;/p></description></item><item><title>Java IO: Creating and Traversing Files And Directories</title><link>https://www.nickolasfisher.com/blog/java-io-creating-and-traversing-files-and-directories/</link><pubDate>Sat, 03 Nov 2018 14:36:55 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-creating-and-traversing-files-and-directories/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>&lt;/p>
&lt;p>Using the static methods in the &lt;code>Files&lt;/code> class, a member of the &lt;code>java.nio.file&lt;/code> package, we can manipulate the file system reasonably easily.&lt;/p></description></item><item><title>Java IO: Paths and Files</title><link>https://www.nickolasfisher.com/blog/java-io-paths-and-files/</link><pubDate>Sat, 03 Nov 2018 13:18:09 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-paths-and-files/</guid><description>&lt;p>The sample code for this repository can be found &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>.&lt;/p>
&lt;p>System paths and file manipulation, usually within the java.nio package, in Java allow you to forgo some of the details related to streaming of files&amp;ndash;which, while they offer low level details and optimization opportunities, typically take longer to develop and get right.&lt;/p></description></item><item><title>Java IO: Zip Archive Manipulation</title><link>https://www.nickolasfisher.com/blog/java-io-zip-archive-manipulation/</link><pubDate>Sat, 03 Nov 2018 12:27:15 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-zip-archive-manipulation/</guid><description>&lt;p>The sample code associated with this post can be found &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>.&lt;/p>
&lt;p>A &lt;a href="https://en.wikipedia.org/wiki/Zip_(file_format)">ZIP file format&lt;/a> is a compressed, lossless archive of files of files and/or directories. While the content being compressed will matter as to the algorithm&amp;rsquo;s effectiveness, it is a common way to transfer files among peers, particularly on many windows machines.&lt;/p></description></item><item><title>Java IO: Input Streaming</title><link>https://www.nickolasfisher.com/blog/java-io-input-streaming/</link><pubDate>Sat, 03 Nov 2018 12:00:01 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-input-streaming/</guid><description>&lt;p>The sample code associated with this post can be found &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>.&lt;/p>
&lt;p>In Java, the input and output stream abstraction can be used with file systems or across networks. While a lot of these abstractions have been abstracted even further
away with modern libraries and tools (via servlets, for example), understanding the basics makes solving things like performance issues a little easier to wrap your head around.&lt;/p></description></item></channel></rss>