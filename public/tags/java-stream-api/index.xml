<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java Stream Api on Nick Fisher's tech blog</title><link>https://www.nickolasfisher.com/tags/java-stream-api/</link><description>Recent content in Java Stream Api on Nick Fisher's tech blog</description><generator>Hugo</generator><language>en-US</language><copyright>2018-{year}</copyright><lastBuildDate>Sat, 03 Nov 2018 14:36:55 +0000</lastBuildDate><atom:link href="https://www.nickolasfisher.com/tags/java-stream-api/index.xml" rel="self" type="application/rss+xml"/><item><title>Java IO: Creating and Traversing Files And Directories</title><link>https://www.nickolasfisher.com/blog/java-io-creating-and-traversing-files-and-directories/</link><pubDate>Sat, 03 Nov 2018 14:36:55 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-creating-and-traversing-files-and-directories/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>&lt;/p>
&lt;p>Using the static methods in the &lt;code>Files&lt;/code> class, a member of the &lt;code>java.nio.file&lt;/code> package, we can manipulate the file system reasonably easily.&lt;/p></description></item><item><title>Java IO: Paths and Files</title><link>https://www.nickolasfisher.com/blog/java-io-paths-and-files/</link><pubDate>Sat, 03 Nov 2018 13:18:09 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/java-io-paths-and-files/</guid><description>&lt;p>The sample code for this repository can be found &lt;a href="https://github.com/nfisher23/iodemos">on Github&lt;/a>.&lt;/p>
&lt;p>System paths and file manipulation, usually within the java.nio package, in Java allow you to forgo some of the details related to streaming of files&amp;ndash;which, while they offer low level details and optimization opportunities, typically take longer to develop and get right.&lt;/p></description></item><item><title>The Java Stream API: Parallel Streams</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-parallel-streams/</link><pubDate>Sun, 21 Oct 2018 20:03:56 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-parallel-streams/</guid><description>&lt;p>The sample code for this post can be found &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>Parallel Streams are simple to generate in Java. Instead of calling .stream(), you simply call parallelStream(). Here, we&amp;rsquo;ll take our familiar list of names:&lt;/p></description></item><item><title>The Java Stream API: Primitive Streams</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-primitive-streams/</link><pubDate>Sun, 21 Oct 2018 19:49:49 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-primitive-streams/</guid><description>&lt;p>The sample code for this post can be found &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>While Streams in Java would typically be used on POJO or POJO-like data structures, Java also lets us deal directly with primitive type streams.
Thanks to Java&amp;rsquo;s type erasure, something like Stream&lt;!-- raw HTML omitted --> would not work, as the type argument must be an Object.&lt;/p></description></item><item><title>The Java Stream API: Reduction Operations</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-reduction-operations/</link><pubDate>Sun, 21 Oct 2018 19:38:40 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-reduction-operations/</guid><description>&lt;p>The sample code for this post can be found &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>Reduction operations are a way to consolidate collections into one simple result.&lt;/p></description></item><item><title>The Java Stream API: Collecting Downstream Elements</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-collecting-downstream-elements/</link><pubDate>Sun, 21 Oct 2018 16:29:32 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-collecting-downstream-elements/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>One interesting feature of collecting streams using the &lt;code>Collectors.groupingBy(..)&lt;/code> method is the ability to manipulate &lt;em>downstream&lt;/em> elements. Basically,
this means that, after you group the keys of the map, you can further make changes to the collection that the map is pointing to. By default, it collects to a list.&lt;/p></description></item><item><title>The Java Stream API: Collecting Into Maps</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-collecting-into-maps/</link><pubDate>Sun, 21 Oct 2018 16:07:06 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-collecting-into-maps/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>Taking a stream of POJOs and transforming it into a map is one of the more common uses of Streams.
There are a few built in ways to get what you want. The simplest way to map one field to another in a POJO is by
using the &lt;code>.toMap(..)&lt;/code> method.&lt;/p></description></item><item><title>The Java Stream API: An Introduction to Collecting Results</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-an-introduction-to-collecting-results/</link><pubDate>Sun, 21 Oct 2018 15:46:38 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-an-introduction-to-collecting-results/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>Calling &lt;code>collect(..)&lt;/code> on a stream terminates a stream into a collection. We&amp;rsquo;ve already seen that calling collect(Collectors.toList()) moves your stream into
a List&lt;!-- raw HTML omitted -->, but you can also collect into a set. If we take our familiar collection of names in a String collection:&lt;/p></description></item><item><title>The Java Stream API: Creating Optional Types</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-creating-optional-types/</link><pubDate>Sun, 21 Oct 2018 15:22:54 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-creating-optional-types/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>While Optionals are often used in conjunction with the Java Stream API, you can also create your own.
Now, why would you want to do that? Simply put, null pointer exceptions are not a fun time, and embracing optional
types will greatly simplify code development, and prevent premature graying hair.&lt;/p></description></item><item><title>The Java Stream API: How to Work With Optional Types</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-how-to-work-with-optional-types/</link><pubDate>Sat, 20 Oct 2018 21:59:38 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-how-to-work-with-optional-types/</guid><description>&lt;p>You can find the sample code associated with this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>If Java programmers had a generic Facebook page, they would collectively have an &amp;ldquo;it&amp;rsquo;s complicated&amp;rdquo; relationship with the null value.&lt;/p></description></item><item><title>The Java Stream API: Concatenating, Sorting, and Flat-Mapping</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-concatenating-sorting-and-flatmapping/</link><pubDate>Sat, 20 Oct 2018 21:32:57 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-concatenating-sorting-and-flatmapping/</guid><description>&lt;p>The sample code associated with this post can be found &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>Sometimes, we will have two different streams of data that we want to aggregate into one stream to analyze. In that case, we can use the &lt;code>Stream.concat(..)&lt;/code> method. Here, if we take our list of names from before:&lt;/p></description></item><item><title>The Java Stream API: Generating Fibonacci Numbers</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-generating-fibonacci-numbers/</link><pubDate>Sat, 20 Oct 2018 21:13:49 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-generating-fibonacci-numbers/</guid><description>&lt;p>You can find the sample code for this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>From the knowledge gained via &lt;a href="https://nickolasfisher.com/blog/The-Java-Stream-API-Creating-Custom-Lazy-Infinite-Streams">creating custom Java Stream objects&lt;/a>, we can start
to have a little bit of fun with this. The fibonacci number sequence starts with [0, 1], and adds each of the previous two elements to create the next element in the sequence.
This looks like [0, 1, 1, 2, 3, 5, 8, 13, 21&amp;hellip;], and goes on &amp;ldquo;forever.&amp;rdquo; We can thus create a template that computes all Fibonacci numbers by implementing a Supplier&lt;!-- raw HTML omitted -->. like so:&lt;/p></description></item><item><title>The Java Stream API: Creating Custom, Lazy, Infinite Streams</title><link>https://www.nickolasfisher.com/blog/the-java-stream-api-creating-custom-lazy-infinite-streams/</link><pubDate>Sat, 20 Oct 2018 13:50:54 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-api-creating-custom-lazy-infinite-streams/</guid><description>&lt;p>You can find the sample code from this post &lt;a href="https://github.com/nfisher23/java_stream_api_samples">on GitHub&lt;/a>.&lt;/p>
&lt;p>There are a few built in ways to create your own custom streams. While many collections offer a direct &lt;code>.stream()&lt;/code> method,
you can also use &lt;code>Stream.of(..)&lt;/code> to just make one in place:&lt;/p></description></item><item><title>The Java Stream API--Introduction: Filter, Map, and Count</title><link>https://www.nickolasfisher.com/blog/the-java-stream-apiintroduction-filter-map-and-count/</link><pubDate>Sat, 20 Oct 2018 12:00:18 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/the-java-stream-apiintroduction-filter-map-and-count/</guid><description>&lt;p>The sample code provided with this series on the Java Stream API can be retrieved &lt;a href="https://github.com/nfisher23/java_stream_api_samples/tree/master">on GitHub&lt;/a>.&lt;/p></description></item></channel></rss>