<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jmh on Nick Fisher's tech blog</title><link>https://www.nickolasfisher.com/tags/jmh/</link><description>Recent content in Jmh on Nick Fisher's tech blog</description><generator>Hugo</generator><language>en-US</language><copyright>2018-{year}</copyright><lastBuildDate>Sat, 17 Nov 2018 19:16:28 +0000</lastBuildDate><atom:link href="https://www.nickolasfisher.com/tags/jmh/index.xml" rel="self" type="application/rss+xml"/><item><title>Improving Java IO Performance: Caching Data, When Appropriate</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-caching-data-when-appropriate/</link><pubDate>Sat, 17 Nov 2018 19:16:28 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-caching-data-when-appropriate/</guid><description>&lt;p>The sample code for this post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>The biggest bottleneck with I/O resources on the filesystem is the operating system, which controls access to the filesystem. Reading from, and writing to, the operating system, is much more expensive than storing data in memory, and that is the subject of this post: caching.&lt;/p></description></item><item><title>Improving Java IO Performance: Does Compression Actually Help?</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-does-compression-actually-help/</link><pubDate>Sat, 17 Nov 2018 18:55:03 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-does-compression-actually-help/</guid><description>&lt;p>The sample code associated with this blog post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>The question &amp;ldquo;does compression actually help?&amp;rdquo; is admittedly pretty loaded. The real answer is &lt;em>sometimes&lt;/em>, and &lt;em>it depends&lt;/em>. I will not try to answer every use case, but I will provide a very specific example here that appears to provide a &amp;ldquo;probably not&amp;rdquo; answer (for this specific use case).&lt;/p></description></item><item><title>Improving Java IO Performance: Appropriately Using Random Access Over Streams</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-appropriately-using-random-access-over-streams/</link><pubDate>Sat, 17 Nov 2018 18:37:39 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-appropriately-using-random-access-over-streams/</guid><description>&lt;p>The sample code for this blog post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>A flavor I/O performance optimization that applies specifically to the filesystem is the decision on when to use Random Access instead of something like a BufferedInputStream. Random access allows for accessing a file in a similar way as a large array of bytes stored on the filesystem. From the &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html">oracle documentation on the RandomAccessFile class&lt;/a>:&lt;/p></description></item><item><title>Improving Java IO Performance: Formatting Costs</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-formatting-costs/</link><pubDate>Sat, 17 Nov 2018 18:27:31 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-formatting-costs/</guid><description>&lt;p>The sample code associated with this blog post can be found &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>Another potential source of I/O bottlenecks, across any medium, could be the process you choose to format the data in in the first place. For example, XML used to be a standard way to send information across the wire or store in a backend system, but the size overhead of XML as compared to JSON is about double (not to mention it&amp;rsquo;s somehow harder to read when formatted compared to JSON).&lt;/p></description></item><item><title>Improving Java IO Performance: Reducing Method Call Overhead</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-reducing-method-call-overhead/</link><pubDate>Sat, 17 Nov 2018 18:06:13 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-reducing-method-call-overhead/</guid><description>&lt;p>You can view the sample code associated with this blog post &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub.&lt;/a>&lt;/p>
&lt;p>While you can achieve massive improvements in I/O operations via &lt;a href="https://nickolasfisher.com/blog/Improving-Java-IO-Performance-Buffering-Techniques">buffering&lt;/a>, another key part of tuning java code in general, which is applicable to I/O bound operations, is method call overhead. Methods that are unnecessarily called repeatedly can bog down operations.&lt;/p></description></item><item><title>Improving Java IO Performance: Buffering Techniques</title><link>https://www.nickolasfisher.com/blog/improving-java-io-performance-buffering-techniques/</link><pubDate>Sat, 10 Nov 2018 12:45:54 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/improving-java-io-performance-buffering-techniques/</guid><description>&lt;p>ï»¿You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/io-tuning">on GitHub&lt;/a>.&lt;/p>
&lt;p>Now that we know &lt;a href="https://nickolasfisher.com/blog/How-to-Benchmark-Java-Code-Using-JUnit-and-JMH">how to benchmark using junit and jmh&lt;/a>, let&amp;rsquo;s put it to the test and try to optimize some basic I/O operations. While filesystem tasks are much less common in the web-enabled world, understanding the basics can help us when we move on to streams across network connections.&lt;/p></description></item><item><title>How to Benchmark Java Code Using JUnit and JMH</title><link>https://www.nickolasfisher.com/blog/how-to-benchmark-java-code-using-junit-and-jmh/</link><pubDate>Sat, 10 Nov 2018 12:28:58 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-benchmark-java-code-using-junit-and-jmh/</guid><description>&lt;p>You can view the sample code associated with this post &lt;a href="https://github.com/nfisher23/jmh-junit-intro">on GitHub&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH&lt;/a> is a lightweight code generator that can benchmark Java code. While many of the performance bottlenecks in today&amp;rsquo;s world are related to network calls and/or database queries, it&amp;rsquo;s still a good idea to understand the performance of our code at a lower level. In particular, by automating performance tests on our code, we can usually at least ensure that the performance was not accidentally made worse by some refactoring effort.&lt;/p></description></item></channel></rss>