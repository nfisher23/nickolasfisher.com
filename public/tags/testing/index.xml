<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Nick Fisher's tech blog</title><link>https://www.nickolasfisher.com/tags/testing/</link><description>Recent content in Testing on Nick Fisher's tech blog</description><generator>Hugo</generator><language>en-US</language><copyright>2018-{year}</copyright><lastBuildDate>Sat, 01 May 2021 18:12:45 +0000</lastBuildDate><atom:link href="https://www.nickolasfisher.com/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>How to Test Latency with a Mock Server in Java</title><link>https://www.nickolasfisher.com/blog/how-to-test-latency-with-a-mock-server-in-java/</link><pubDate>Sat, 01 May 2021 18:12:45 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-test-latency-with-a-mock-server-in-java/</guid><description>&lt;p>The source code for what follows &lt;a href="https://github.com/nfisher23/java-failure-and-resilience">can be found on Github&lt;/a>.&lt;/p>
&lt;p>Very often, you will want to test service api clients using a &lt;a href="https://www.mock-server.com/">Mock Server&lt;/a> [for example, &lt;a href="https://nickolasfisher.com/blog/How-to-use-Mock-Server-to-End-to-End-Test-Any-WebClient-Calls-in-Spring-Boot-Webflux">testing the spring webclient with mockserver&lt;/a>]. And since network latency is a fact of life, not something we can merely ignore, actually injecting some latency to simulate timeouts will give us greater confidence that our system will behave as expected.&lt;/p></description></item><item><title>How to Prevent DEBUG Logging by Test Containers when Running Unit Tests in Java</title><link>https://www.nickolasfisher.com/blog/how-to-prevent-debug-logging-by-test-containers-when-running-unit-tests-in-java/</link><pubDate>Sat, 24 Apr 2021 20:35:47 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-prevent-debug-logging-by-test-containers-when-running-unit-tests-in-java/</guid><description>&lt;p>I have been playing around with test containers lately [ &lt;a href="https://nickolasfisher.com/blog/How-to-use-a-Redis-Test-Container-with-LettuceSpring-Boot-Webflux">redis test containers for testing lettuce&lt;/a> and &lt;a href="https://nickolasfisher.com/blog/Setup-and-Use-a-DynamoDB-Test-Container-with-the-AWS-Java-SDK-20">dynamodb test containers for testing the AWS SDK 2.0&lt;/a>, to be specific], and I found soon after using them that I was getting by default a stream of DEBUG level logs whenever I ran my test suite. This was annoying, so I went digging for a solution.&lt;/p></description></item><item><title>How to use a Redis Test Container with Lettuce/Spring Boot Webflux</title><link>https://www.nickolasfisher.com/blog/how-to-use-a-redis-test-container-with-lettucespring-boot-webflux/</link><pubDate>Sat, 27 Mar 2021 23:52:07 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-use-a-redis-test-container-with-lettucespring-boot-webflux/</guid><description>&lt;p>The source code for this post &lt;a href="https://github.com/nfisher23/reactive-programming-webflux/tree/master/reactive-redis">can be found on Github&lt;/a>.&lt;/p>
&lt;p>Another way to write integration tests for code that verifies your interactions with redis actually make sense is to use a &lt;a href="https://www.testcontainers.org/">test container&lt;/a>. This framework assumes you have docker up and running, but if you do it will pull a specified container image [typically you&amp;rsquo;ll just use docker hub, though it&amp;rsquo;s important to note that they rate limit you, so don&amp;rsquo;t go overboard], then you can interact with that container in your integration tests.&lt;/p></description></item><item><title>A Guide to Automatic Retries in Reactor</title><link>https://www.nickolasfisher.com/blog/a-guide-to-automatic-retries-in-reactor/</link><pubDate>Sun, 16 Aug 2020 16:22:09 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/a-guide-to-automatic-retries-in-reactor/</guid><description>&lt;p>The source code for this post &lt;a href="https://github.com/nfisher23/reactive-programming-webflux">is available on GitHub&lt;/a>.&lt;/p>
&lt;p>One of the nice things about a reactive programming model is there is a significantly lower risk of doomsday when things start getting latent all at once. You don&amp;rsquo;t have threads upstream blocking and waiting for a response, therefore they won&amp;rsquo;t all seize up and stop serving requests [or they won&amp;rsquo;t short circuit if you&amp;rsquo;re using a resiliency library like hystrix].&lt;/p></description></item><item><title>How to use Mock Server to End to End Test Any WebClient Calls in Spring Boot Webflux</title><link>https://www.nickolasfisher.com/blog/how-to-use-mock-server-to-end-to-end-test-any-webclient-calls-in-spring-boot-webflux/</link><pubDate>Sat, 08 Aug 2020 22:44:14 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-use-mock-server-to-end-to-end-test-any-webclient-calls-in-spring-boot-webflux/</guid><description>&lt;p>The source code for this post &lt;a href="https://github.com/nfisher23/reactive-programming-webflux/tree/master/mocking-and-unit-testing">can be found on Github&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://www.mock-server.com">Mock Server&lt;/a> is a really simple and straightforward way to actually let your application make downstream calls and intercept them. That level of abstraction is really nice to have, and gives at least me much more confidence that my code is actually working in a microservices environment.&lt;/p></description></item><item><title>How to Configure Rest Assured to Record the Latency of Every Request In a Custom Way</title><link>https://www.nickolasfisher.com/blog/how-to-configure-rest-assured-to-record-the-latency-of-every-request-in-a-custom-way/</link><pubDate>Sat, 13 Jun 2020 21:06:52 +0000</pubDate><guid>https://www.nickolasfisher.com/blog/how-to-configure-rest-assured-to-record-the-latency-of-every-request-in-a-custom-way/</guid><description>&lt;p>Sample code associated with this post can be found &lt;a href="https://github.com/nfisher23/examples-testing-stuff">on Github&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://github.com/rest-assured/rest-assured/wiki/Usage">Rest Assured&lt;/a> is a library that makes it easy to write api based automated tests in java. Recently I needed to find a way to record the latency of each request as well as some metadata about it [request path, method, things of that nature]. I found a nice way to do this with &lt;a href="https://github.com/rest-assured/rest-assured/wiki/Usage#filters">rest assured filters&lt;/a>, and I&amp;rsquo;m going to share that with you in this article.&lt;/p></description></item></channel></rss>